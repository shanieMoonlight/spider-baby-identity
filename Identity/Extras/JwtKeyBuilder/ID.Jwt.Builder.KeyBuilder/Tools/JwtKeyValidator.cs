using ID.Jwt.KeyBuilder.Utility;
using System.Security.Cryptography;
using System.Text;

namespace ID.Jwt.KeyBuilder.Tools;

/// <summary>
/// Tool to validate JWT key files generated by the library
/// </summary>
public static class JwtKeyValidator
{
    /// <summary>
    /// Validate a pair of JWT key files
    /// </summary>
    /// <param name="privateKeyPath">Path to the private key file</param>
    /// <param name="publicKeyPath">Path to the public key file</param>
    /// <returns>True if keys are valid and work together</returns>
    public static bool ValidateKeyPair(string privateKeyPath, string publicKeyPath)
    {
        Console.WriteLine($"üîç Validating key pair:");
        Console.WriteLine($"   Private: {privateKeyPath}");
        Console.WriteLine($"   Public:  {publicKeyPath}");
        Console.WriteLine();

        try
        {
            // Check if files exist
            if (!File.Exists(privateKeyPath))
            {
                Console.WriteLine("‚ùå Private key file not found");
                return false;
            }

            if (!File.Exists(publicKeyPath))
            {
                Console.WriteLine("‚ùå Public key file not found");
                return false;
            }

            if (!AreFileOfTheSameType(privateKeyPath, publicKeyPath))
            {
                Console.WriteLine("‚ùå Public key file and Private Key File are not of the same type");
                return false;
            }

            // Read the key files
            var privateKeyPem = File.ReadAllText(privateKeyPath);
            var publicKeyPem = File.ReadAllText(publicKeyPath);

            if (IsXmlKeyFile(publicKeyPath))
            {
                privateKeyPem = XmlToPem.ConvertPrivateKey(privateKeyPem);
                publicKeyPem = XmlToPem.ConvertPublicKey(publicKeyPem);
            }


            return ValidateKeyContent(privateKeyPem, publicKeyPem);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Error validating keys: {ex.Message}");
            return false;
        }
    }

    //-------------------------------//

    private static bool IsXmlKeyFile(string keyPath) =>
        keyPath.Trim().EndsWith(".xml", StringComparison.OrdinalIgnoreCase);

    //-------------------------------//

    private static bool AreFileOfTheSameType(string privateKeyPath, string publicKeyPath) =>
        Path.GetExtension(privateKeyPath).Equals(Path.GetExtension(publicKeyPath), StringComparison.CurrentCultureIgnoreCase);

    //-------------------------------//

    /// <summary>
    /// Validate JWT key content (PEM strings)
    /// </summary>
    /// <param name="privateKeyPem">Private key in PEM format</param>
    /// <param name="publicKeyPem">Public key in PEM format</param>
    /// <returns>True if keys are valid and work together</returns>
    public static bool ValidateKeyContent(string privateKeyPem, string publicKeyPem)
    {
        try
        {
            Console.WriteLine("üîç Validating key content...");

            // 1. Check PEM format
            if (!IsValidPemFormat(privateKeyPem, true))
            {
                Console.WriteLine("‚ùå Private key is not in valid PEM format");
                return false;
            }

            if (!IsValidPemFormat(publicKeyPem, false))
            {
                Console.WriteLine("‚ùå Public key is not in valid PEM format");
                return false;
            }

            Console.WriteLine("‚úÖ PEM format validation passed");

            // 2. Try to import keys into .NET RSA
            using var rsaPrivate = RSA.Create();
            using var rsaPublic = RSA.Create();

            rsaPrivate.ImportFromPem(privateKeyPem);
            rsaPublic.ImportFromPem(publicKeyPem);

            Console.WriteLine("‚úÖ Keys successfully imported into .NET RSA");

            // 3. Check key sizes match
            if (rsaPrivate.KeySize != rsaPublic.KeySize)
            {
                Console.WriteLine($"‚ùå Key size mismatch: Private={rsaPrivate.KeySize}, Public={rsaPublic.KeySize}");
                return false;
            }

            Console.WriteLine($"‚úÖ Key size validation passed ({rsaPrivate.KeySize} bits)");

            // 4. Test encryption/decryption
            var testMessage = "JWT Key Validation Test üîê"u8.ToArray();

            var encrypted = rsaPublic.Encrypt(testMessage, RSAEncryptionPadding.Pkcs1);
            var decrypted = rsaPrivate.Decrypt(encrypted, RSAEncryptionPadding.Pkcs1);

            var decryptedText = Encoding.UTF8.GetString(decrypted);
            if (decryptedText != "JWT Key Validation Test üîê")
            {
                Console.WriteLine("‚ùå Encryption/decryption test failed");
                return false;
            }

            Console.WriteLine("‚úÖ Encryption/decryption test passed");

            // 5. Test digital signature
            var signature = rsaPrivate.SignData(testMessage, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            var isValidSignature = rsaPublic.VerifyData(testMessage, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

            if (!isValidSignature)
            {
                Console.WriteLine("‚ùå Digital signature test failed");
                return false;
            }

            Console.WriteLine("‚úÖ Digital signature test passed");

            // 6. Test JWT-specific algorithms (RS256)
            var jwtTestPassed = TestJwtCompatibility(rsaPrivate, rsaPublic);
            if (!jwtTestPassed)
            {
                Console.WriteLine("‚ùå JWT compatibility test failed");
                return false;
            }

            Console.WriteLine("‚úÖ JWT compatibility test passed");

            Console.WriteLine();
            Console.WriteLine("üéâ ALL VALIDATION TESTS PASSED!");
            Console.WriteLine("üéâ Keys are valid and ready for JWT use!");

            return true;
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Validation failed: {ex.Message}");
            return false;
        }
    }

    //-------------------------------//

    /// <summary>
    /// Check if the content is in valid PEM format
    /// </summary>
    private static bool IsValidPemFormat(string pemContent, bool isPrivateKey)
    {
        if (string.IsNullOrWhiteSpace(pemContent))
            return false;

        pemContent = pemContent.Trim();

        if (isPrivateKey)
        {
            return (pemContent.StartsWith(JwtKeyBuilderConstants.PRIVATE_PEM_BEGIN) && pemContent.EndsWith(JwtKeyBuilderConstants.PRIVATE_PEM_END)) ||
                   (pemContent.StartsWith(JwtKeyBuilderConstants.PRIVATE_PEM_RSA_BEGIN) && pemContent.EndsWith(JwtKeyBuilderConstants.PRIVATE_PEM_RSA_END));
        }
        else
        {
            return (pemContent.StartsWith(JwtKeyBuilderConstants.PUBLIC_PEM_BEGIN) && pemContent.EndsWith(JwtKeyBuilderConstants.PUBLIC_PEM_END)) ||
                   (pemContent.StartsWith(JwtKeyBuilderConstants.PUBLIC_PEM_RSA_BEGIN) && pemContent.EndsWith(JwtKeyBuilderConstants.PUBLIC_PEM_RSA_END));
        }
    }

    //-------------------------------//

    /// <summary>
    /// Test JWT-specific compatibility (RS256 algorithm)
    /// </summary>
    private static bool TestJwtCompatibility(RSA privateKey, RSA publicKey)
    {
        try
        {
            // Create a simple JWT-like payload
            var header = """{"alg":"RS256","typ":"JWT"}""";
            var payload = """{"sub":"test","name":"JWT Key Validator","iat":1234567890}""";

            // Base64Url encode (simplified for testing)
            var headerEncoded = Convert.ToBase64String(Encoding.UTF8.GetBytes(header)).TrimEnd('=').Replace('+', '-').Replace('/', '_');
            var payloadEncoded = Convert.ToBase64String(Encoding.UTF8.GetBytes(payload)).TrimEnd('=').Replace('+', '-').Replace('/', '_');

            var signingInput = $"{headerEncoded}.{payloadEncoded}";
            var signingBytes = Encoding.UTF8.GetBytes(signingInput);

            // Sign with RS256 (SHA256 + RSA)
            var signature = privateKey.SignData(signingBytes, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);
            
            // Verify signature
            var isValid = publicKey.VerifyData(signingBytes, signature, HashAlgorithmName.SHA256, RSASignaturePadding.Pkcs1);

            return isValid;
        }
        catch
        {
            return false;
        }
    }

    //-------------------------------//

    /// <summary>
    /// Interactive key validation tool
    /// </summary>
    public static void RunInteractiveValidator()
    {
        Console.WriteLine("üîë JWT Key Validator Tool");
        Console.WriteLine("=" + new string('=', 40));
        Console.WriteLine();

        while (true)
        {
            Console.WriteLine("Options:");
            Console.WriteLine("1. Validate key files");
            Console.WriteLine("2. Generate and validate new keys");
            Console.WriteLine("3. Exit");
            Console.Write("\nSelect option (1-3): ");

            var input = Console.ReadLine();

            switch (input)
            {
                case "1":
                    ValidateExistingKeys();
                    break;
                case "2":
                    GenerateAndValidateKeys();
                    break;
                case "3":
                    return;
                default:
                    Console.WriteLine("Invalid option. Please select 1-3.");
                    break;
            }

            Console.WriteLine();
        }
    }

    //-------------------------------//

    private static void ValidateExistingKeys()
    {
        Console.Write("Enter private key file path: ");
        var privatePath = Console.ReadLine();

        Console.Write("Enter public key file path: ");
        var publicPath = Console.ReadLine();

        if (string.IsNullOrWhiteSpace(privatePath) || string.IsNullOrWhiteSpace(publicPath))
        {
            Console.WriteLine("‚ùå Please provide both file paths");
            return;
        }

        ValidateKeyPair(privatePath, publicPath);
    }

    //-------------------------------//

    private static void GenerateAndValidateKeys()
    {
        Console.Write("Enter directory to save keys (or press Enter for temp): ");
        var directory = Console.ReadLine();

        if (string.IsNullOrWhiteSpace(directory))
        {
            directory = Path.Combine(Path.GetTempPath(), $"jwt-validation-{DateTime.Now:yyyyMMdd-HHmmss}");
        }

        Console.Write("Enter key size in bits (default 2048): ");
        var keySizeInput = Console.ReadLine();
        var keySize = 2048;

        if (!string.IsNullOrWhiteSpace(keySizeInput) && int.TryParse(keySizeInput, out var parsedSize))
        {
            keySize = parsedSize;
        }

        try
        {
            Console.WriteLine($"\nüîß Generating {keySize}-bit keys in: {directory}");
            var keyData = JwtPemBuilder.GenerateJwtPemKeys(directory, keySize);

            Console.WriteLine("‚úÖ Keys generated successfully");
            Console.WriteLine();

            ValidateKeyPair(keyData.PrivatePath, keyData.PublicPath);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"‚ùå Failed to generate keys: {ex.Message}");
        }
    }


}//Cls
